<!DOCTYPE html>
<html>
<head>
    <title>Comprehensive Thinking Test</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .test-name { font-weight: bold; color: #333; }
        .test-result { margin-top: 10px; padding: 5px; border-radius: 3px; }
        .pass { background-color: #d4edda; color: #155724; }
        .fail { background-color: #f8d7da; color: #721c24; }
        pre { background-color: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Comprehensive Thinking Test</h1>
    <div id="results"></div>
    
    <script>
        // Copy of the updated extractAndCleanThought function
        function extractAndCleanThought(content) {
            if (!content || typeof content !== 'string') return { cleanedAnswer: content, extractedThinking: '' };
            
            // Regex patterns for different thinking tags
            const thoughtRegex = /<(thinking|thought|thoughts|reasoning|reason|plan|planning|analysis|analyzing|reflection|reflecting|consideration|considering|deliberation|deliberating|ponder|pondering|cogitate|cogitating|brainstorm|brainstorming|evaluate|evaluating|assess|assessing|review|reviewing|examine|examining)>([\s\S]*?)<\/\1>/gi;
            const untaggedThinkingRegex = /(?:^|\n)(thinking|thought|thoughts|reasoning|reason|plan|planning|analysis|analyzing|reflection|reflecting|consideration|considering|deliberation|deliberating|ponder|pondering|cogitate|cogitating|brainstorm|brainstorming|evaluate|evaluating|assess|assessing|review|reviewing|examine|examining)[\s\S]*?(?=\n\n|\n[A-Z]|\nI |\nThe |\nYou |\nThis |$)/gi;
            const reasoningPrefixRegex = /^[\s\S]*?(Here are my reasoning steps:[\s\S]*?)(?=\n\n[A-Z]|$)/i;
            
            let thoughts = [];
            let match;
            
            // Extract tagged thinking content
            while ((match = thoughtRegex.exec(content)) !== null) {
                thoughts.push(match[0].trim());
            }
            
            // Extract untagged thinking content
            while ((match = untaggedThinkingRegex.exec(content)) !== null) {
                const alreadyExtracted = thoughts.some(thought => thought.includes(match[0]));
                if (!alreadyExtracted && match[0].trim().length > 10) {
                    thoughts.push(match[0].trim());
                }
            }
            
            // Extract reasoning prefix if present
            const reasoningMatch = content.match(reasoningPrefixRegex);
            if (reasoningMatch) {
                thoughts.push(reasoningMatch[1].trim());
            }
            
            // Extract first person conflict sections
            const conflictIndex = content.indexOf('I need to be careful not to show the user my thinking process');
            if (conflictIndex !== -1) {
                const potentialAnswer = content.substring(0, conflictIndex).trim();
                const potentialThinking = content.substring(conflictIndex).trim();
                if (potentialAnswer.length > 20 && potentialThinking.length > 10 &&
                    !potentialThinking.includes('I ') && !potentialThinking.includes('my ') && !potentialThinking.includes('me ') &&
                    (potentialThinking.includes('user') || potentialThinking.includes('system') ||
                     potentialThinking.includes('conflict') || potentialThinking.includes('think') ||
                     potentialThinking.includes('reasoning') || potentialThinking.includes('prompt') ||
                     potentialThinking.includes('instruction') || potentialThinking.includes('task') ||
                     potentialThinking.includes('perspective') || potentialThinking.includes('setting') ||
                     potentialThinking.includes('lighting') || potentialThinking.includes('photo') ||
                     potentialThinking.includes('detailed') || potentialThinking.includes('photorealistic'))) {
                    thoughts.push(potentialThinking);
                }
            }
            
            // New pattern: Extract narrative thinking content that precedes the final response
            // This handles cases where the AI writes out its thinking process in a narrative format
            const narrativeThinkingPattern = /^([\s\S]*?)(\n\n[A-Z][^.]*[.!?]\s*[A-Z][^.]*[.!?][\s\S]*)$/;
            const narrativeMatch = content.match(narrativeThinkingPattern);
            if (narrativeMatch && narrativeMatch[1].length > 50 && 
                (narrativeMatch[1].includes('should') || narrativeMatch[1].includes('need to') || 
                 narrativeMatch[1].includes('want to') || narrativeMatch[1].includes('going to') ||
                 narrativeMatch[1].includes('I ') || narrativeMatch[1].includes('my '))) {
                // Check if the second part looks like a final response
                const finalResponse = narrativeMatch[2].trim();
                if (finalResponse.length > 10 && 
                    (finalResponse.includes('!') || finalResponse.includes('?') || finalResponse.includes('üòä') || finalResponse.includes('ü§†') ||
                     finalResponse.includes('üëã') || finalResponse.includes('üòâ') || finalResponse.includes('üòÑ') || finalResponse.includes('üòÅ'))) {
                    thoughts.push(narrativeMatch[1].trim());
                }
            }
            
            // Additional pattern: Handle cases where the thinking content is separated by a single newline
            const singleNewlinePattern = /^([\s\S]*?)(\n[A-Z][^.]*[.!?]\s*[A-Z][^.]*[.!?][\s\S]*)$/;
            const singleNewlineMatch = content.match(singleNewlinePattern);
            if (singleNewlineMatch && singleNewlineMatch[1].length > 50 && 
                !thoughts.some(thought => thought.includes(singleNewlineMatch[1])) && // Avoid duplicates
                (singleNewlineMatch[1].includes('should') || singleNewlineMatch[1].includes('need to') || 
                 singleNewlineMatch[1].includes('want to') || singleNewlineMatch[1].includes('going to') ||
                 singleNewlineMatch[1].includes('I ') || singleNewlineMatch[1].includes('my '))) {
                // Check if the second part looks like a final response
                const finalResponse = singleNewlineMatch[2].trim();
                if (finalResponse.length > 10 && 
                    (finalResponse.includes('!') || finalResponse.includes('?') || finalResponse.includes('üòä') || finalResponse.includes('ü§†') ||
                     finalResponse.includes('üëã') || finalResponse.includes('üòâ') || finalResponse.includes('üòÑ') || finalResponse.includes('üòÅ'))) {
                    thoughts.push(singleNewlineMatch[1].trim());
                }
            }
            
            // Clean the answer by removing all thinking content
            let cleanedAnswer = content;
            for (const thought of thoughts) {
                cleanedAnswer = cleanedAnswer.replace(thought, '');
            }
            
            // Remove empty thinking tags
            cleanedAnswer = cleanedAnswer.replace(thoughtRegex, '').trim();
            
            // Clean up excessive newlines
            cleanedAnswer = cleanedAnswer.replace(/\n{3,}/g, '\n\n').trim();
            
            // Extract JSON if present at the end of the answer
            const startBraceIndex = cleanedAnswer.indexOf('{');
            const endBraceIndex = cleanedAnswer.lastIndexOf('}');
            
            if (startBraceIndex !== -1 && endBraceIndex > startBraceIndex) {
                const potentialJson = cleanedAnswer.substring(startBraceIndex, endBraceIndex + 1);
                try {
                    JSON.parse(potentialJson);
                    cleanedAnswer = potentialJson;
                } catch (e) {
                    // Not valid JSON, keep as is
                }
            }
            
            // Join all extracted thinking content
            const extractedThinking = thoughts.join('\n\n');
            
            return { cleanedAnswer, extractedThinking };
        }
        
        // Test cases
        const testCases = [
            {
                name: "Narrative thinking with final response",
                input: `Okay, the user sent "Howdy ". They're greeting me, so I should respond in a friendly manner. Looking at the conversation history, I see they've asked about my thinking process before. They might be testing how I handle different greetings or just starting a new topic.\nI should keep the response warm and engaging. Maybe add an emoji to keep it light. I want to show I'm approachable and ready to help with whatever they need next. So, I'll say something like, "Hey Andy! Howdy back at ya! What brings you here today?" and add a friendly emoji.\n\nHey Andy! Howdy back at ya! What brings you here today? ü§†üòä`,
                expected: "Hey Andy! Howdy back at ya! What brings you here today? ü§†üòä"
            },
            {
                name: "Tagged thinking content",
                input: `<thinking>I need to analyze this question carefully and provide a helpful response.</thinking>\n\nThe answer to your question is 42.`,
                expected: "The answer to your question is 42."
            },
            {
                name: "Simple clean response",
                input: "Hello! How can I help you today?",
                expected: "Hello! How can I help you today?"
            },
            {
                name: "Reasoning prefix",
                input: "Here are my reasoning steps: First, I need to understand the question. Then, I'll formulate a response. Finally, I'll check if it's helpful.\n\nBased on my analysis, the best approach is to be direct and helpful.",
                expected: "Based on my analysis, the best approach is to be direct and helpful."
            }
        ];
        
        // Run tests
        window.onload = function() {
            const results = document.getElementById('results');
            let allPassed = true;
            
            testCases.forEach((testCase, index) => {
                const { cleanedAnswer, extractedThinking } = extractAndCleanThought(testCase.input);
                const passed = cleanedAnswer.trim() === testCase.expected.trim();
                if (!passed) allPassed = false;
                
                const testCaseDiv = document.createElement('div');
                testCaseDiv.className = 'test-case';
                testCaseDiv.innerHTML = `
                    <div class="test-name">Test ${index + 1}: ${testCase.name}</div>
                    <div><strong>Input:</strong></div>
                    <pre>${testCase.input}</pre>
                    <div><strong>Extracted Thinking:</strong></div>
                    <pre>${extractedThinking || 'No thinking content extracted'}</pre>
                    <div><strong>Cleaned Answer:</strong></div>
                    <pre>${cleanedAnswer}</pre>
                    <div><strong>Expected:</strong></div>
                    <pre>${testCase.expected}</pre>
                    <div class="test-result ${passed ? 'pass' : 'fail'}">
                        ${passed ? '‚úÖ PASS' : '‚ùå FAIL'}
                    </div>
                `;
                
                results.appendChild(testCaseDiv);
            });
            
            const summary = document.createElement('div');
            summary.innerHTML = `<h2>Overall Result: ${allPassed ? '‚úÖ ALL TESTS PASSED' : '‚ùå SOME TESTS FAILED'}</h2>`;
            results.insertBefore(summary, results.firstChild);
        };
    </script>
</body>
</html>