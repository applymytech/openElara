<!DOCTYPE html>
<html>
<head>
    <title>Final Test</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script>
</head>
<body>
    <h1>Final Test</h1>
    <div id="results"></div>
    
    <script>
        // Copy of the updated extractAndCleanThought function
        function extractAndCleanThought(content) {
            if (!content || typeof content !== 'string') return { cleanedAnswer: content, extractedThinking: '' };
            
            // Regex patterns for different thinking tags
            const thoughtRegex = /<(thinking|thought|thoughts|reasoning|reason|plan|planning|analysis|analyzing|reflection|reflecting|consideration|considering|deliberation|deliberating|ponder|pondering|cogitate|cogitating|brainstorm|brainstorming|evaluate|evaluating|assess|assessing|review|reviewing|examine|examining)>([\s\S]*?)<\/\1>/gi;
            const untaggedThinkingRegex = /(?:^|\n)(thinking|thought|thoughts|reasoning|reason|plan|planning|analysis|analyzing|reflection|reflecting|consideration|considering|deliberation|deliberating|ponder|pondering|cogitate|cogitating|brainstorm|brainstorming|evaluate|evaluating|assess|assessing|review|reviewing|examine|examining)[\s\S]*?(?=\n\n|\n[A-Z]|\nI |\nThe |\nYou |\nThis |$)/gi;
            const reasoningPrefixRegex = /^[\s\S]*?(Here are my reasoning steps:[\s\S]*?)(?=\n\n[A-Z]|$)/i;
            
            let thoughts = [];
            let match;
            
            // Extract tagged thinking content
            while ((match = thoughtRegex.exec(content)) !== null) {
                thoughts.push(match[0].trim());
            }
            
            // Extract untagged thinking content
            while ((match = untaggedThinkingRegex.exec(content)) !== null) {
                const alreadyExtracted = thoughts.some(thought => thought.includes(match[0]));
                if (!alreadyExtracted && match[0].trim().length > 10) {
                    thoughts.push(match[0].trim());
                }
            }
            
            // Extract reasoning prefix if present
            const reasoningMatch = content.match(reasoningPrefixRegex);
            if (reasoningMatch) {
                thoughts.push(reasoningMatch[1].trim());
            }
            
            // Extract first person conflict sections
            const conflictIndex = content.indexOf('I need to be careful not to show the user my thinking process');
            if (conflictIndex !== -1) {
                const potentialAnswer = content.substring(0, conflictIndex).trim();
                const potentialThinking = content.substring(conflictIndex).trim();
                if (potentialAnswer.length > 20 && potentialThinking.length > 10 &&
                    !potentialThinking.includes('I ') && !potentialThinking.includes('my ') && !potentialThinking.includes('me ') &&
                    (potentialThinking.includes('user') || potentialThinking.includes('system') ||
                     potentialThinking.includes('conflict') || potentialThinking.includes('think') ||
                     potentialThinking.includes('reasoning') || potentialThinking.includes('prompt') ||
                     potentialThinking.includes('instruction') || potentialThinking.includes('task') ||
                     potentialThinking.includes('perspective') || potentialThinking.includes('setting') ||
                     potentialThinking.includes('lighting') || potentialThinking.includes('photo') ||
                     potentialThinking.includes('detailed') || potentialThinking.includes('photorealistic'))) {
                    thoughts.push(potentialThinking);
                }
            }
            
            // New pattern: Extract narrative thinking content that precedes the final response
            // This handles cases where the AI writes out its thinking process in a narrative format
            const narrativeThinkingPattern = /^([\s\S]*?)(\n\n[A-Z][^.]*[.!?]\s*[A-Z][^.]*[.!?][\s\S]*)$/;
            const narrativeMatch = content.match(narrativeThinkingPattern);
            if (narrativeMatch && narrativeMatch[1].length > 50 && 
                (narrativeMatch[1].includes('should') || narrativeMatch[1].includes('need to') || 
                 narrativeMatch[1].includes('want to') || narrativeMatch[1].includes('going to') ||
                 narrativeMatch[1].includes('I ') || narrativeMatch[1].includes('my '))) {
                // Check if the second part looks like a final response
                const finalResponse = narrativeMatch[2].trim();
                if (finalResponse.length > 10 && 
                    (finalResponse.includes('!') || finalResponse.includes('?') || finalResponse.includes('üòä') || finalResponse.includes('ü§†') ||
                     finalResponse.includes('üëã') || finalResponse.includes('üòâ') || finalResponse.includes('üòÑ') || finalResponse.includes('üòÅ'))) {
                    thoughts.push(narrativeMatch[1].trim());
                }
            }
            
            // Additional pattern: Handle cases where the thinking content is separated by a single newline
            const singleNewlinePattern = /^([\s\S]*?)(\n[A-Z][^.]*[.!?]\s*[A-Z][^.]*[.!?][\s\S]*)$/;
            const singleNewlineMatch = content.match(singleNewlinePattern);
            if (singleNewlineMatch && singleNewlineMatch[1].length > 50 && 
                !thoughts.some(thought => thought.includes(singleNewlineMatch[1])) && // Avoid duplicates
                (singleNewlineMatch[1].includes('should') || singleNewlineMatch[1].includes('need to') || 
                 singleNewlineMatch[1].includes('want to') || singleNewlineMatch[1].includes('going to') ||
                 singleNewlineMatch[1].includes('I ') || singleNewlineMatch[1].includes('my '))) {
                // Check if the second part looks like a final response
                const finalResponse = singleNewlineMatch[2].trim();
                if (finalResponse.length > 10 && 
                    (finalResponse.includes('!') || finalResponse.includes('?') || finalResponse.includes('üòä') || finalResponse.includes('ü§†') ||
                     finalResponse.includes('üëã') || finalResponse.includes('üòâ') || finalResponse.includes('üòÑ') || finalResponse.includes('üòÅ'))) {
                    thoughts.push(singleNewlineMatch[1].trim());
                }
            }
            
            // Clean the answer by removing all thinking content
            let cleanedAnswer = content;
            for (const thought of thoughts) {
                cleanedAnswer = cleanedAnswer.replace(thought, '');
            }
            
            // Remove empty thinking tags
            cleanedAnswer = cleanedAnswer.replace(thoughtRegex, '').trim();
            
            // Clean up excessive newlines
            cleanedAnswer = cleanedAnswer.replace(/\n{3,}/g, '\n\n').trim();
            
            // Extract JSON if present at the end of the answer
            const startBraceIndex = cleanedAnswer.indexOf('{');
            const endBraceIndex = cleanedAnswer.lastIndexOf('}');
            
            if (startBraceIndex !== -1 && endBraceIndex > startBraceIndex) {
                const potentialJson = cleanedAnswer.substring(startBraceIndex, endBraceIndex + 1);
                try {
                    JSON.parse(potentialJson);
                    cleanedAnswer = potentialJson;
                } catch (e) {
                    // Not valid JSON, keep as is
                }
            }
            
            // Join all extracted thinking content
            const extractedThinking = thoughts.join('\n\n');
            
            return { cleanedAnswer, extractedThinking };
        }
        
        // Test with the exact example from the user
        window.onload = function() {
            const pollutedContent = `Okay, the user sent "Howdy ". They're greeting me, so I should respond in a friendly manner. Looking at the conversation history, I see they've asked about my thinking process before. They might be testing how I handle different greetings or just starting a new topic.
I should keep the response warm and engaging. Maybe add an emoji to keep it light. I want to show I'm approachable and ready to help with whatever they need next. So, I'll say something like, "Hey Andy! Howdy back at ya! What brings you here today?" and add a friendly emoji.

Hey Andy! Howdy back at ya! What brings you here today? ü§†üòä`;
            
            const { cleanedAnswer, extractedThinking } = extractAndCleanThought(pollutedContent);
            
            const results = document.getElementById('results');
            results.innerHTML = `
                <h2>Original Content:</h2>
                <pre>${pollutedContent}</pre>
                
                <h2>Extracted Thinking:</h2>
                <pre>${extractedThinking || 'No thinking content extracted'}</pre>
                
                <h2>Cleaned Answer:</h2>
                <pre>${cleanedAnswer}</pre>
                
                <h2>Expected Clean Answer:</h2>
                <pre>Hey Andy! Howdy back at ya! What brings you here today? ü§†üòä</pre>
                
                <h2>Test Result:</h2>
                <p style="font-size: 24px; font-weight: bold;">${cleanedAnswer.trim() === 'Hey Andy! Howdy back at ya! What brings you here today? ü§†üòä' ? '‚úÖ PASS' : '‚ùå FAIL'}</p>
            `;
        };
    </script>
</body>
</html>